---
title: "Penguins"
format: html
---

<!--
=============================================================================
QUARTO + SHINY TUTORIAL
=============================================================================

This document demonstrates how to create interactive visualizations using
Shiny within a Quarto document. This is the Shiny equivalent of the
Observable JS version (penguins_observable.qmd).

KEY CONCEPTS:
1. server: shiny      → Enables Shiny server in the YAML header
2. {r} code blocks    → R code for data processing and plotting
3. input$variable     → Access values from UI inputs
4. render functions   → renderPlot(), renderTable() create reactive outputs
5. Inputs             → sliderInput(), checkboxGroupInput(), etc.

KEY DIFFERENCES FROM OBSERVABLE:
- Observable runs in the browser (client-side JavaScript)
- Shiny runs on a server (server-side R)
- Observable uses automatic reactivity based on variable dependencies
- Shiny uses explicit input$/output$ bindings
=============================================================================
-->

A simple example based on Allison Horst's [Palmer Penguins](https://allisonhorst.github.io/palmerpenguins/) dataset. Here we look at how penguin body mass varies across both sex and species (use the provided inputs to filter the dataset by bill length and island):

<!--
=============================================================================
SECTION 1: INTERACTIVE INPUT CONTROLS
=============================================================================
Shiny inputs are created with *Input() functions.
Each input needs a unique inputId that you'll reference as input$inputId
-->

```{r}
#| eval: false
#| panel: input

# -----------------------------------------------------------------------------
# SLIDER INPUT
# -----------------------------------------------------------------------------
# sliderInput() creates a slider control
#
# Arguments:
#   inputId: "bill_length_min" → Unique ID, accessed as input$bill_length_min
#   label: "..."               → Text label displayed above the slider
#   min: 32                    → Minimum allowed value
#   max: 50                    → Maximum allowed value
#   value: 35                  → Initial/default value
#   step: 1                    → Increment amount
#
# Compare to Observable:
#   viewof bill_length_min = Inputs.range([32, 50], {value: 35, step: 1, label: "..."})

sliderInput(
  inputId = "bill_length_min",
  label = "Bill length (min):",
  min = 32,
  max = 50,
  value = 35,
  step = 1
)

# -----------------------------------------------------------------------------
# CHECKBOX GROUP INPUT
# -----------------------------------------------------------------------------
# checkboxGroupInput() creates a group of checkboxes
#
# Arguments:
#   inputId: "islands"                        → Unique ID, accessed as input$islands
#   label: "Islands:"                         → Text label for the group
#   choices: c("Torgersen", "Biscoe", "Dream") → Available options
#   selected: c("Torgersen", "Biscoe")        → Initially checked values
#
# The input$islands will contain a character vector of selected values
# e.g., c("Torgersen", "Biscoe") or "Dream" or NULL (if none selected)
#
# Compare to Observable:
#   viewof islands = Inputs.checkbox(["Torgersen", "Biscoe", "Dream"],
#                                    {value: ["Torgersen", "Biscoe"], label: "Islands:"})

checkboxGroupInput(
  inputId = "islands",
  label = "Islands:",
  choices = c("Torgersen", "Biscoe", "Dream"),
  selected = c("Torgersen", "Biscoe")
)
```

<!--
=============================================================================
SECTION 2: TABBED PANEL FOR PLOT AND DATA
=============================================================================
The ::: {.panel-tabset} creates a tabbed interface (same as Observable version).
Each ## heading becomes a tab.
-->

::: {.panel-tabset}

## Plot

<!--
This tab contains the main visualization - a faceted histogram
-->

```{r}
#| eval: false
#| label: plot

# -----------------------------------------------------------------------------
# REACTIVE PLOT OUTPUT
# -----------------------------------------------------------------------------
# plotOutput() creates a placeholder in the UI for a plot
# The actual plot is rendered by renderPlot() in the server context block below
#
# Compare to Observable:
#   In OJS, you just write the Plot code directly and it renders automatically

plotOutput("penguin_plot")
```

## Data

<!--
This tab shows the raw filtered data in an interactive table
-->

```{r}
#| eval: false
#| label: data-table

# -----------------------------------------------------------------------------
# REACTIVE TABLE OUTPUT
# -----------------------------------------------------------------------------
# tableOutput() creates a placeholder for a table
# The actual table is rendered by renderTable() in the server context block
#
# For more interactive tables, you could use:
#   DT::dataTableOutput("penguin_table") with DT::renderDataTable()
#
# Compare to Observable:
#   Inputs.table(filtered)

tableOutput("penguin_table")
```

:::

<!--
=============================================================================
SECTION 3: SERVER CONTEXT (SHINY BACKEND)
=============================================================================
This is where the reactive logic lives. Code here runs on the server.
The #| context: server directive tells Quarto this is server-side code.
-->

```{r}
#| eval: false
#| context: server

# -----------------------------------------------------------------------------
# LOAD REQUIRED LIBRARIES
# -----------------------------------------------------------------------------
library(ggplot2)
library(dplyr)

# -----------------------------------------------------------------------------
# LOAD DATA
# -----------------------------------------------------------------------------
# Read the CSV file once when the app starts
# In Shiny, data loading typically happens outside reactive contexts
# for better performance (load once, use many times)
#
# Compare to Observable:
#   data = FileAttachment("palmer-penguins.csv").csv({ typed: true })

data <- read.csv("palmer-penguins.csv")

# -----------------------------------------------------------------------------
# REACTIVE FILTERED DATA
# -----------------------------------------------------------------------------
# reactive() creates a reactive expression that automatically updates
# when its dependencies (input$bill_length_min, input$islands) change
#
# Call it as filtered() - note the parentheses! It's a function.
#
# Compare to Observable:
#   filtered = data.filter(function(penguin) {
#     return bill_length_min < penguin.bill_length_mm &&
#            islands.includes(penguin.island);
#   })
#
# KEY DIFFERENCE: In Shiny, you explicitly wrap reactive code in reactive({})
# In Observable, reactivity is automatic based on variable references

filtered <- reactive({
  # Handle case when no islands are selected
  req(input$islands)  # Don't run if islands is NULL/empty

  data |>
    filter(
      bill_length_mm > input$bill_length_min,
      island %in% input$islands
    ) |>
    # Remove rows with NA values for cleaner plotting
    filter(!is.na(body_mass_g), !is.na(sex), !is.na(species))
})

# -----------------------------------------------------------------------------
# RENDER PLOT
# -----------------------------------------------------------------------------
# renderPlot() creates a reactive plot that re-renders when dependencies change
# The output$penguin_plot connects to plotOutput("penguin_plot") in the UI
#
# Compare to Observable Plot:
#   Plot.rectY(filtered, Plot.binX({y: "count"}, {x: "body_mass_g", fill: "species"}))
#     .plot({facet: {data: filtered, x: "sex", y: "species"}})
#
# Here we use ggplot2 which has similar concepts:
#   - geom_histogram() ≈ Plot.rectY() + Plot.binX()
#   - facet_grid()     ≈ facet: {x: "sex", y: "species"}
#   - fill = species   ≈ fill: "species"

output$penguin_plot <- renderPlot({
  ggplot(filtered(), aes(x = body_mass_g, fill = species)) +
    geom_histogram(bins = 20, color = "white", linewidth = 0.2) +
    facet_grid(species ~ sex) +
    labs(
      x = "Body Mass (g)",
      y = "Count",
      fill = "Species"
    ) +
    theme_minimal() +
    theme(
      strip.text = element_text(size = 12, face = "bold"),
      legend.position = "bottom"
    )
})

# -----------------------------------------------------------------------------
# RENDER TABLE
# -----------------------------------------------------------------------------
# renderTable() creates a reactive table that updates when filtered() changes
# The output$penguin_table connects to tableOutput("penguin_table") in the UI
#
# Compare to Observable:
#   Inputs.table(filtered)

output$penguin_table <- renderTable({
  filtered()
})
```

<!--
=============================================================================
SUMMARY: HOW SHINY REACTIVITY FLOWS
=============================================================================

1. User moves the slider or checks/unchecks a box
2. input$bill_length_min or input$islands updates on the server
3. Shiny detects that filtered() depends on these inputs
4. filtered() is automatically recomputed with new filter criteria
5. Shiny detects that output$penguin_plot and output$penguin_table
   depend on filtered()
6. Both outputs automatically re-render with the new data

SHINY vs OBSERVABLE COMPARISON:
┌─────────────────────┬────────────────────────┬─────────────────────────┐
│ Concept             │ Observable             │ Shiny                   │
├─────────────────────┼────────────────────────┼─────────────────────────┤
│ Where code runs     │ Browser (JavaScript)   │ Server (R)              │
│ Reactivity          │ Automatic              │ Explicit (reactive())   │
│ Input binding       │ viewof variable        │ input$inputId           │
│ Output binding      │ Just use variable      │ output$outputId         │
│ Slider              │ Inputs.range()         │ sliderInput()           │
│ Checkboxes          │ Inputs.checkbox()      │ checkboxGroupInput()    │
│ Table               │ Inputs.table()         │ tableOutput()           │
│ Plot library        │ Observable Plot        │ ggplot2 (or others)     │
└─────────────────────┴────────────────────────┴─────────────────────────┘

=============================================================================
NEXT STEPS TO TRY
=============================================================================

1. Add more Shiny input types:
   - selectInput() for dropdowns
   - radioButtons() for radio buttons
   - textInput() for text input
   - dateInput() for date pickers

2. Try other plot types with ggplot2:
   - geom_point() for scatter plots
   - geom_line() for line charts
   - geom_bar() for bar charts
   - geom_area() for area charts

3. Add interactivity to plots:
   - Use plotly::ggplotly() for hover tooltips
   - Use shiny's click/hover/brush handlers

4. Learn more:
   - Shiny: https://shiny.posit.co/
   - Quarto + Shiny: https://quarto.org/docs/interactive/shiny/
   - ggplot2: https://ggplot2.tidyverse.org/
=============================================================================
-->
